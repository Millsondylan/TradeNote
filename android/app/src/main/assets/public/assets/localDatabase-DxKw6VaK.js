import{S as e,C as t}from"./database-ES7LaSYZ.js";import{C as r}from"./capacitor-3Yedw1XA.js";const a=new class{sqlite;db=null;isInitialized=!1;isMobile=r.isNativePlatform();constructor(){this.sqlite=new e(t)}async initialize(){if(!this.isInitialized)try{this.isMobile,this.db=await this.sqlite.createConnection("tradenote",!1,"no-encryption",1,!1),await this.db.open(),await this.createTables(),this.isInitialized=!0}catch(e){throw new Error(`Database initialization failed: ${e instanceof Error?e.message:"Unknown error"}`)}}async createTables(){if(!this.db)throw new Error("Database not initialized");try{await this.db.execute("\n        CREATE TABLE IF NOT EXISTS users (\n          id TEXT PRIMARY KEY,\n          email TEXT UNIQUE NOT NULL,\n          name TEXT NOT NULL,\n          password TEXT,\n          tradingStyle TEXT,\n          riskTolerance TEXT,\n          experienceLevel TEXT,\n          preferences TEXT,\n          createdAt TEXT NOT NULL,\n          updatedAt TEXT NOT NULL\n        )\n      "),await this.db.execute("\n        CREATE TABLE IF NOT EXISTS trades (\n          id TEXT PRIMARY KEY,\n          symbol TEXT NOT NULL,\n          type TEXT NOT NULL,\n          entryPrice REAL NOT NULL,\n          exitPrice REAL,\n          quantity REAL NOT NULL,\n          entryDate TEXT NOT NULL,\n          exitDate TEXT,\n          profit REAL,\n          notes TEXT,\n          tags TEXT,\n          confidence INTEGER,\n          mood TEXT,\n          stopLoss REAL,\n          takeProfit REAL,\n          screenshot TEXT,\n          strategy TEXT,\n          market TEXT,\n          session TEXT,\n          createdAt TEXT NOT NULL,\n          updatedAt TEXT NOT NULL\n        )\n      "),await this.db.execute("\n        CREATE TABLE IF NOT EXISTS watchlist (\n          id TEXT PRIMARY KEY,\n          symbol TEXT NOT NULL,\n          name TEXT,\n          currentPrice REAL,\n          change REAL,\n          changePercent REAL,\n          addedAt TEXT NOT NULL\n        )\n      "),await this.db.execute("\n        CREATE TABLE IF NOT EXISTS alerts (\n          id TEXT PRIMARY KEY,\n          symbol TEXT NOT NULL,\n          type TEXT NOT NULL,\n          condition TEXT NOT NULL,\n          value TEXT NOT NULL,\n          message TEXT NOT NULL,\n          isActive INTEGER NOT NULL,\n          createdAt TEXT NOT NULL\n        )\n      "),await this.db.execute("\n        CREATE TABLE IF NOT EXISTS performance_metrics (\n          id TEXT PRIMARY KEY,\n          date TEXT NOT NULL,\n          totalTrades INTEGER,\n          winningTrades INTEGER,\n          losingTrades INTEGER,\n          totalProfit REAL,\n          totalLoss REAL,\n          winRate REAL,\n          profitFactor REAL,\n          averageWin REAL,\n          averageLoss REAL,\n          maxDrawdown REAL,\n          sharpeRatio REAL,\n          createdAt TEXT NOT NULL\n        )\n      "),await this.db.execute("CREATE INDEX IF NOT EXISTS idx_trades_symbol ON trades(symbol)"),await this.db.execute("CREATE INDEX IF NOT EXISTS idx_trades_date ON trades(entryDate)"),await this.db.execute("CREATE INDEX IF NOT EXISTS idx_trades_type ON trades(type)"),await this.db.execute("CREATE INDEX IF NOT EXISTS idx_watchlist_symbol ON watchlist(symbol)"),await this.db.execute("CREATE INDEX IF NOT EXISTS idx_alerts_active ON alerts(isActive)")}catch(e){throw new Error(`Failed to create database tables: ${e instanceof Error?e.message:"Unknown error"}`)}}async createUser(e){if(!this.db)throw new Error("Database not initialized");try{await this.db.run("INSERT INTO users (id, email, name, password, tradingStyle, riskTolerance, experienceLevel, preferences, createdAt, updatedAt)\n         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",[e.id,e.email,e.name,e.password||null,e.tradingStyle,e.riskTolerance,e.experienceLevel,JSON.stringify(e.preferences),e.createdAt,e.updatedAt])}catch(t){throw new Error(`Failed to create user: ${t instanceof Error?t.message:"Unknown error"}`)}}async getUser(e){if(!this.db)throw new Error("Database not initialized");try{const t=await this.db.query("SELECT * FROM users WHERE id = ?",[e]);if(t.values&&t.values.length>0){const e=t.values[0];return{...e,preferences:JSON.parse(e.preferences)}}return null}catch(t){throw new Error(`Failed to get user: ${t instanceof Error?t.message:"Unknown error"}`)}}async getUserByName(e){if(!this.db)throw new Error("Database not initialized");try{const t=await this.db.query("SELECT * FROM users WHERE name = ?",[e]);if(t.values&&t.values.length>0){const e=t.values[0];return{...e,preferences:JSON.parse(e.preferences)}}return null}catch(t){throw new Error(`Failed to get user by name: ${t instanceof Error?t.message:"Unknown error"}`)}}async getUsers(){if(!this.db)throw new Error("Database not initialized");try{const e=await this.db.query("SELECT * FROM users");return e.values?e.values.map(e=>({...e,preferences:JSON.parse(e.preferences)})):[]}catch(e){throw new Error(`Failed to get users: ${e instanceof Error?e.message:"Unknown error"}`)}}async updateUser(e){if(!this.db)throw new Error("Database not initialized");try{await this.db.run("UPDATE users SET \n         email = ?, name = ?, password = ?, tradingStyle = ?, \n         riskTolerance = ?, experienceLevel = ?, preferences = ?, updatedAt = ?\n         WHERE id = ?",[e.email,e.name,e.password||null,e.tradingStyle,e.riskTolerance,e.experienceLevel,JSON.stringify(e.preferences),e.updatedAt,e.id])}catch(t){throw new Error(`Failed to update user: ${t instanceof Error?t.message:"Unknown error"}`)}}async deleteUser(e){if(!this.db)throw new Error("Database not initialized");try{await this.db.run("DELETE FROM trades WHERE id IN (SELECT id FROM users WHERE id = ?)",[e]),await this.db.run("DELETE FROM watchlist WHERE id IN (SELECT id FROM users WHERE id = ?)",[e]),await this.db.run("DELETE FROM alerts WHERE id IN (SELECT id FROM users WHERE id = ?)",[e]),await this.db.run("DELETE FROM performance_metrics WHERE id IN (SELECT id FROM users WHERE id = ?)",[e]),await this.db.run("DELETE FROM users WHERE id = ?",[e])}catch(t){throw new Error(`Failed to delete user: ${t instanceof Error?t.message:"Unknown error"}`)}}async createTrade(e){if(!this.db)throw new Error("Database not initialized");try{await this.db.run("INSERT INTO trades (id, symbol, type, entryPrice, exitPrice, quantity, entryDate, exitDate, profit, notes, tags, confidence, mood, stopLoss, takeProfit, screenshot, strategy, market, session, createdAt, updatedAt)\n         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",[e.id||crypto.randomUUID(),e.symbol,e.type,e.entryPrice,e.exitPrice||null,e.quantity,e.entryDate,e.exitDate||null,e.profit||null,e.notes||null,e.tags?JSON.stringify(e.tags):null,e.confidence||null,e.mood||null,e.stopLoss||null,e.takeProfit||null,e.screenshot||null,e.strategy||null,e.market||null,e.session||null,e.createdAt,e.updatedAt])}catch(t){throw new Error(`Failed to create trade: ${t instanceof Error?t.message:"Unknown error"}`)}}async getTrades(e){if(!this.db)throw new Error("Database not initialized");try{let t="SELECT * FROM trades WHERE 1=1";const r=[];e?.symbol&&(t+=" AND symbol = ?",r.push(e.symbol)),e?.type&&(t+=" AND type = ?",r.push(e.type)),e?.startDate&&(t+=" AND entryDate >= ?",r.push(e.startDate)),e?.endDate&&(t+=" AND entryDate <= ?",r.push(e.endDate)),t+=" ORDER BY entryDate DESC",e?.limit&&(t+=" LIMIT ?",r.push(e.limit)),e?.offset&&(t+=" OFFSET ?",r.push(e.offset));const a=await this.db.query(t,r);return a.values?a.values.map(e=>({...e,tags:e.tags?JSON.parse(e.tags):[]})):[]}catch(t){throw new Error(`Failed to get trades: ${t instanceof Error?t.message:"Unknown error"}`)}}async updateTrade(e){if(!this.db)throw new Error("Database not initialized");try{await this.db.run("UPDATE trades SET \n         symbol = ?, type = ?, entryPrice = ?, exitPrice = ?, quantity = ?, \n         entryDate = ?, exitDate = ?, profit = ?, notes = ?, tags = ?, \n         confidence = ?, mood = ?, stopLoss = ?, takeProfit = ?, screenshot = ?, \n         strategy = ?, market = ?, session = ?, updatedAt = ?\n         WHERE id = ?",[e.symbol,e.type,e.entryPrice,e.exitPrice||null,e.quantity,e.entryDate,e.exitDate||null,e.profit||null,e.notes||null,e.tags?JSON.stringify(e.tags):null,e.confidence||null,e.mood||null,e.stopLoss||null,e.takeProfit||null,e.screenshot||null,e.strategy||null,e.market||null,e.session||null,e.updatedAt,e.id])}catch(t){throw new Error(`Failed to update trade: ${t instanceof Error?t.message:"Unknown error"}`)}}async deleteTrade(e){if(!this.db)throw new Error("Database not initialized");try{await this.db.run("DELETE FROM trades WHERE id = ?",[e])}catch(t){throw new Error(`Failed to delete trade: ${t instanceof Error?t.message:"Unknown error"}`)}}async addToWatchlist(e){if(!this.db)throw new Error("Database not initialized");try{await this.db.run("INSERT OR REPLACE INTO watchlist (id, symbol, name, currentPrice, change, changePercent, addedAt)\n         VALUES (?, ?, ?, ?, ?, ?, ?)",[e.id||crypto.randomUUID(),e.symbol,e.name||null,e.currentPrice||null,e.change||null,e.changePercent||null,e.addedAt])}catch(t){throw new Error(`Failed to add to watchlist: ${t instanceof Error?t.message:"Unknown error"}`)}}async getWatchlist(){if(!this.db)throw new Error("Database not initialized");try{const e=await this.db.query("SELECT * FROM watchlist ORDER BY addedAt DESC");return e.values?e.values:[]}catch(e){throw new Error(`Failed to get watchlist: ${e instanceof Error?e.message:"Unknown error"}`)}}async removeFromWatchlist(e){if(!this.db)throw new Error("Database not initialized");try{await this.db.run("DELETE FROM watchlist WHERE symbol = ?",[e])}catch(t){throw new Error(`Failed to remove from watchlist: ${t instanceof Error?t.message:"Unknown error"}`)}}async createAlert(e){if(!this.db)throw new Error("Database not initialized");try{await this.db.run("INSERT INTO alerts (id, symbol, type, condition, value, message, isActive, createdAt)\n         VALUES (?, ?, ?, ?, ?, ?, ?, ?)",[e.id||crypto.randomUUID(),e.symbol,e.type,e.condition,e.value.toString(),e.message,e.isActive?1:0,e.createdAt])}catch(t){throw new Error(`Failed to create alert: ${t instanceof Error?t.message:"Unknown error"}`)}}async getAlerts(){if(!this.db)throw new Error("Database not initialized");try{const e=await this.db.query("SELECT * FROM alerts ORDER BY createdAt DESC");return e.values?e.values.map(e=>({...e,isActive:Boolean(e.isActive)})):[]}catch(e){throw new Error(`Failed to get alerts: ${e instanceof Error?e.message:"Unknown error"}`)}}async updateAlert(e){if(!this.db)throw new Error("Database not initialized");try{await this.db.run("UPDATE alerts SET \n         symbol = ?, type = ?, condition = ?, value = ?, message = ?, isActive = ?\n         WHERE id = ?",[e.symbol,e.type,e.condition,e.value.toString(),e.message,e.isActive?1:0,e.id])}catch(t){throw new Error(`Failed to update alert: ${t instanceof Error?t.message:"Unknown error"}`)}}async deleteAlert(e){if(!this.db)throw new Error("Database not initialized");try{await this.db.run("DELETE FROM alerts WHERE id = ?",[e])}catch(t){throw new Error(`Failed to delete alert: ${t instanceof Error?t.message:"Unknown error"}`)}}async savePerformanceMetrics(e){if(!this.db)throw new Error("Database not initialized");try{await this.db.run("INSERT OR REPLACE INTO performance_metrics (id, date, totalTrades, winningTrades, losingTrades, totalProfit, totalLoss, winRate, profitFactor, averageWin, averageLoss, maxDrawdown, sharpeRatio, createdAt)\n         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",[crypto.randomUUID(),e.date,e.totalTrades||0,e.winningTrades||0,e.losingTrades||0,e.totalProfit||0,e.totalLoss||0,e.winRate||0,e.profitFactor||0,e.averageWin||0,e.averageLoss||0,e.maxDrawdown||0,e.sharpeRatio||0,(new Date).toISOString()])}catch(t){throw new Error(`Failed to save performance metrics: ${t instanceof Error?t.message:"Unknown error"}`)}}async getPerformanceMetrics(e,t){if(!this.db)throw new Error("Database not initialized");try{let r="SELECT * FROM performance_metrics WHERE 1=1";const a=[];e&&(r+=" AND date >= ?",a.push(e)),t&&(r+=" AND date <= ?",a.push(t)),r+=" ORDER BY date DESC";const n=await this.db.query(r,a);return n.values?n.values:[]}catch(r){throw new Error(`Failed to get performance metrics: ${r instanceof Error?r.message:"Unknown error"}`)}}async exportData(){if(!this.db)throw new Error("Database not initialized");try{const e=await this.getUsers(),t=await this.getTrades(),r=await this.getWatchlist(),a=await this.getAlerts(),n=await this.getPerformanceMetrics();return{version:"1.0",exportDate:(new Date).toISOString(),users:e,trades:t,watchlist:r,alerts:a,performanceMetrics:n}}catch(e){throw new Error(`Failed to export data: ${e instanceof Error?e.message:"Unknown error"}`)}}async importData(e){if(!this.db)throw new Error("Database not initialized");try{await this.db.run("DELETE FROM users"),await this.db.run("DELETE FROM trades"),await this.db.run("DELETE FROM watchlist"),await this.db.run("DELETE FROM alerts"),await this.db.run("DELETE FROM performance_metrics");for(const t of e.users||[])await this.createUser(t);for(const t of e.trades||[])await this.createTrade(t);for(const t of e.watchlist||[])await this.addToWatchlist(t);for(const t of e.alerts||[])await this.createAlert(t);for(const t of e.performanceMetrics||[])await this.savePerformanceMetrics(t)}catch(t){throw new Error(`Failed to import data: ${t instanceof Error?t.message:"Unknown error"}`)}}async close(){if(this.db)try{await this.db.close()}catch(e){}}async getDatabaseInfo(){if(!this.db)throw new Error("Database not initialized");try{const e=await this.getUsers(),t=await this.getTrades(),r=await this.getWatchlist(),a=await this.getAlerts();return{platform:this.isMobile?"Mobile":"Web",initialized:this.isInitialized,userCount:e.length,tradeCount:t.length,watchlistCount:r.length,alertCount:a.length,lastUpdated:(new Date).toISOString()}}catch(e){throw new Error(`Failed to get database info: ${e instanceof Error?e.message:"Unknown error"}`)}}};export{a as l};
